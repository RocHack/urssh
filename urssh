#!/usr/bin/env bash

username=
format="%m"
cmd=

verbose=false
quiet=false
action=ssh
fast=true
each=false
volume=

for arg; do
    case "$arg" in
        (--verbose|-v)
            verbose=true
            quiet=false
            volume=-v
            ;;

        (--quiet|-q)
            verbose=false
            quiet=true
            volume=-q
            ;;

        (--list|-l)
            action=list
            ;;

        (--ssh|-s)
            action=ssh
            ;;

        (--fast|-f)
            fast=true
            each=false
            ;;

        (--each|-e)
            each=true
            fast=false
            ;;

        (--all|-a)
            fast=false
            ;;

        (--user=*|--username=*)
            username="$(awk -F= '{print $2}' <<< "$arg")"
            ;;

        (--format=*)
            format="$(awk -F= '{print $2}' <<< "$arg")"
            ;;

        (--command=*)
            cmd="$(awk -F= '{print $2}' <<< "$arg")"
            ;;

        (--help|-h)
            cat <<EOF
usage: $0 [--verbose | -v] [--quiet | -q] [--list | -l] [--ssh | -s]
    [--fast | -f] [--each | -e] [--all | -a] [--username=USER | --user=USER ]
    [--format=FORMAT] [--command=COMMAND]

--list - List each computer with some information about that computer. By
         default, the information is the number of unique users and then the
         list of unique users. Different information can be gotten by passing
         --command=COMMAND. COMMAND is eval'd on the remote computer.

--ssh  - Uses heuristics (implemented in get_rating()) to get the best computer
to ssh into, and then ssh's into that computer.

--each - ssh's into each computer. This is designed to allow shell ~/.*rc
scripts to run and do any global initialization on each computer, or just to
run some command on each computer.

--fast - Opposite of --all. Times out the ssh command so that you don't wait
all that long for computers that are slow to respond.

--all  - Opposite of --fast. Doesn't timeout the ssh commands, so that you list
all the computers possible, rather than just the fast ones to respond.

--username=USER - Use USER as the username for ssh.

--format=FORMAT - Use FORMAT for formatting computer names. The format is a
literal string, but with a few printf-like specifiers:
    %% - '%'
    %m - The short computer name
    %M - The long computer name
    %u - The username

--command=COMMAND -
    For --list, specifies the command to get the output to list for each computer.
    For --each, specifies a command to run on each computer.
    For --ssh, specifies the command used to get the rating for each computer -
        the rating should be a number, with lower numbers being more favorable.
EOF
            exit
            ;;

        (--get)
            action=get
            ;;

        (*)
            echo "error: unrecognized argument: $arg" >&2
            exit 1
            ;;
    esac
done

if [[ -z $cmd ]]; then
    case "$action" in
        (list)
            cmd='echo $(n_uniq_users) $(uniq_users | format_locked)'
            ;;

        (ssh)
            $each || cmd='get_rating'
            ;;

        (*)
            echo "This shouldn't happen." >&2
            exit 1
            ;;
    esac
fi

if $verbose; then
    echo "username = $username" >&2
    echo "format   = $format" >&2
    echo "cmd      = $cmd" >&2
    echo "verbose  = $verbose" >&2
    echo "quiet    = $quiet" >&2
    echo "volume   = $volume" >&2
    echo "action   = $action" >&2
    echo "fast     = $fast" >&2
    echo "each     = $each" >&2
fi

sub()
{
    echo 's/\([^%]\|^\)'"$1"'/\1'"$2"'/g'
}

format_machine()
{
    local user machine_short machine_long

    if grep -qF @ <<< "$1"; then
        user="$(awk -F@ '{print $1}' <<< "$1")"
    else
        # Not necessarily accurate, but the best we can do easily
        user="$USER"
    fi
    machine_long="$(sed "s/^$user@//" <<< "$1")"
    machine_short="$(awk -F. '{print $1}' <<< "$machine_long")"

    sed "
        $(sub "%m" "$machine_short")
        $(sub "%M" "$machine_long")
        $(sub "%u" "$user")
        s/%%/%/g
    " <<< "$format"
}

format_machines()
{
    local machine

    while read -r machine; do
        format_machine "$machine"
    done
}

get_machines()
{
    if [[ -z $username ]]; then
        userstring=
    else
        userstring="$username@"
    fi

    for i in $(seq 3); do
        echo "${userstring}cycle${i}.csug.rochester.edu"
    done

    if echo "$HOSTNAME" | grep -qF cycle; then
        minors="algonquin armstrong cliff colvin gothics haystack hough iroquois marshall panther redfield skylight whiteface wright"
        majors="blake cascade colden macomb marcy nye phelps porter sawteeth seward tabletop"
        for i in $majors $minors; do
            echo "$userstring${i}.csug.rochester.edu"
        done
    fi
}

get_formated_machines()
{
    get_machines | format_machines
}

get_users()
{
    users | tr ' ' '\n'
}

uniq_users()
{
    get_users | sort | uniq
}

n_users()
{
    get_users | wc -l
}

n_uniq_users()
{
    uniq_users | wc -l
}

format_locked()
{
    PATH="$PATH:~jkottas/bin"
    if ! hash screensaver-check 2>/dev/null; then
        cat
        return
    fi

    locked_users="$(screensaver-check)"
    tr ' ' '\n' | while read -r usr; do
        if grep -q "^$usr$" <<<"$locked_users"; then
            printf '%s(?)\n' "$usr"
        else
            printf '%s\n' "$usr"
        fi
    done
}

meminfo()
{
    awk -F':? +' "\$1 == \"$1\" {print \$2}" /proc/meminfo
}

mem_avail()
{
    meminfo MemAvailable
}

cpuinfo()
{
    lscpu | awk -F': +' "\$1 == \"$1\" {print \$2}"
}

n_cpus()
{
    cpuinfo "CPU(s)"
}

load_avgs()
{
    uptime | awk -F'[,:] ' '{print $NF, $(NF - 1), $(NF - 2)}'
}

load_avgs_avg()
{
    bc -l <<< "($(load_avgs | sed 's/ /+/g')) / 3"
}

get_rating()
{
    bc -l <<EOF
n_uniq_users  = $(n_uniq_users)
load_avgs_avg = $(load_avgs_avg)
n_cpus        = $(n_cpus)
mem_avail     = $(mem_avail)

(n_uniq_users + 1) * (load_avgs_avg + 1) / (n_cpus * \
   (mem_avail / 1048576))
EOF
}

do_ssh()
{
    machine="$1"
    ssh_cmd=ssh
    if $fast; then
        ssh_cmd="timeout 2 ssh"
    fi

    if ! $ssh_cmd "$machine" true 2>/dev/null; then
        $quiet || echo "Unable to ssh into $(format_machine "$machine")" >&2
        return 1
    fi

    if $fast; then
        ssh_cmd="timeout 3 ssh"
    fi

    ! $verbose || echo "MACHINE: $machine" >&2
    ! $verbose || echo "COMMAND: $2" >&2

    $ssh_cmd "$machine" "$2"
}

machines="$(get_machines)"

case "$action" in
    (get)
        eval "$cmd"
        ;;

    (ssh)
        if $each; then
            for machine in $machines; do
                $quiet || echo \
                    "sshing into $(format_machine "$machine")"
                do_ssh "$machine" "$cmd"
            done
        else
            tmpdir="$(mktemp -d tmp.XXXXXXXX)"
            ! $verbose || echo "tmpdir = $tmpdir" >&2
            for machine in $machines; do
                do_ssh "$machine" "urssh $volume --get '--command=$cmd'" \
                    >"$tmpdir/$machine" &
            done
            wait
            min=inf
            minmachine=
            for machine in $machines; do
                rating="$(cat "$tmpdir/$machine")"
                if [[ -n $rating ]] && [[ $min = inf || \
                    "$(bc <<< "$rating < $min")" = 1 ]]; then
                    min="$rating"
                    minmachine="$machine"
                fi
            done
            exec ssh "$minmachine"
        fi
        ;;

    (list)
        tmpdir="$(mktemp -d tmp.XXXXXXXX)"
        ! $verbose || echo "tmpdir = $tmpdir" >&2
        for machine in $machines; do
            do_ssh "$machine" "urssh $volume --get '--command=$cmd'" \
                >"$tmpdir/$machine" &
        done
        wait
        for machine in $machines; do
            info="$(cat "$tmpdir/$machine")"
            [[ -n $info ]] && echo "$(format_machine "$machine") $info"
        done
        ;;

    (*)
        echo 'error: unknown action' >&2
        exit 1
esac
